<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>解决跨域问题 | kaelyn</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">解决跨域问题</h1><a id="logo" href="/.">kaelyn</a><p class="description">kaelyn's blog</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">解决跨域问题</h1><div class="post-meta">Oct 22, 2017<span> | </span><span class="category"><a href="/categories/questions/">questions</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么会有跨域问题"><span class="toc-number">1.</span> <span class="toc-text">为什么会有跨域问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#判断是否同源"><span class="toc-number">2.</span> <span class="toc-text">判断是否同源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSONP实现跨域"><span class="toc-number">3.</span> <span class="toc-text">JSONP实现跨域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CORS-跨源资源分享"><span class="toc-number">4.</span> <span class="toc-text">CORS(跨源资源分享)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CORS与JSONP比较"><span class="toc-number">5.</span> <span class="toc-text">CORS与JSONP比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务器代理实现跨域"><span class="toc-number">6.</span> <span class="toc-text">服务器代理实现跨域</span></a></li></ol></div></div><div class="post-content"><p>&emsp;&emsp;介绍一下如何解决跨域问题。</p>
<hr>
<h2 id="为什么会有跨域问题"><a href="#为什么会有跨域问题" class="headerlink" title="为什么会有跨域问题"></a>为什么会有跨域问题</h2><p>&emsp;&emsp;为了阻止一个页面上的恶意脚本通过页面的DOM对象获得访问另一个页面上敏感信息的权限，浏览器采用了同源策略。<br>&emsp;&emsp;在这个策略下，只有在两个页面有相同的<strong>源</strong>时，web 浏览器允许一个页面的脚本访问另一个页面里的数据。<br>&emsp;&emsp;浏览器的同源策略又分为两种：</p>
<ul>
<li>DOM同源策略：禁止对不同源页面DOM进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的。</li>
<li>XmlHttpRequest同源策略：禁止使用XHR对象向不同源的服务器地址发起HTTP请求。</li>
</ul>
<p>&emsp;&emsp;同源策略限制的范围：</p>
<ul>
<li>无法读取<strong>Cookie</strong>、<strong>LocalStorage</strong> 和 <strong>IndexDB</strong> 。</li>
<li>无法获取<strong>DOM</strong> 。</li>
<li>不能发送 <strong>Ajax 请求</strong>。</li>
</ul>
<hr>
<h2 id="判断是否同源"><a href="#判断是否同源" class="headerlink" title="判断是否同源"></a>判断是否同源</h2><p>&emsp;&emsp;假设一个 URL 为 <code>http://www.example.com/dir/page.html</code>，以其为例判断以下 URL 是否同源：<br>|<table><tr><td bgcolor="rgb(234,236,240)">URL 对比</td></tr></table> |<table><tr><td bgcolor="rgb(234,236,240)">结果</td></tr></table>   | <table><tr><td bgcolor="rgb(234,236,240)">原因</td></tr></table> |<br>|:————-:|:————-:|:—–:|<br>| <code>http://www.example.com/dir/page2.html</code> | <table><tr><td bgcolor="rgb(153，255，153)">同源</td></tr></table> | 相同的协议,主机和端口 |<br>| <code>http://www.example.com/dir2/other.html</code> | <table><tr><td bgcolor="rgb(153，255，153)">同源</td></tr></table> | 相同的协议,主机和端口 |<br>| <code>http://username:password@www.example.com/dir2/other.html</code> | <table><tr><td bgcolor="rgb(153，255，153)">同源</td></tr></table> | 相同的协议,主机和端口 |<br>| <code>http://www.example.com:81/dir/other.html</code> | <table><tr><td bgcolor="rgb(255，153，153)">不同源</td></tr></table> | 相同的协议和主机但端口不同 |<br>| <code>https://www.example.com/dir/other.html</code> | <table><tr><td bgcolor="rgb(255，153，153)">不同源</td></tr></table> | 协议不同 |<br>| <code>http://en.example.com/dir/other.html</code> | <table><tr><td bgcolor="rgb(255，153，153)">不同源</td></tr></table> | 不同主机 |<br>| <code>http://example.com/dir/other.html</code> | <table><tr><td bgcolor="rgb(255，153，153)">不同源</td></tr></table> | 不同主机(需要精确匹配) |<br>| <code>http://www.example.com:80/dir/other.html</code> | <table><tr><td bgcolor="rgb(255，153，153)">待定</td></tr></table> | 端口明确，依赖浏览器实现 |</p>
<hr>
<h2 id="JSONP实现跨域"><a href="#JSONP实现跨域" class="headerlink" title="JSONP实现跨域"></a>JSONP实现跨域</h2><p>&emsp;&emsp;<strong>jsonp</strong> 利用了 <code>&lt;script&gt;</code> 标签中 <strong>src 属性能够跨域访问</strong>的特性，先定义了一个回调方法，然后将其当作 <strong>url 参数</strong>的一部分发送到服务端，服务端通过<strong>字符串拼接</strong>的方式将用户想要的<strong>数据</strong>包裹在回调方法中，再传回来，<strong>返回的 js 脚本直接就会执行了</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">	// 定义一个回调函数函数</span><br><span class="line">	function callback(data) &#123;</span><br><span class="line">	    console.log(data);</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 创建一个脚本，并且告诉服务端端回调函数名叫callback</span><br><span class="line">	var script = document.createElement(&apos;script&apos;);</span><br><span class="line">	var url = &apos;http://localhost:3000/jsonp?callback=callback&apos;;</span><br><span class="line">  	script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);</span><br><span class="line">  	script.src = url;</span><br><span class="line"> 		document.body.appendChild(script);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;使用 <strong>node.js</strong> 写服务端代码响应请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* GET jsonp listing. */</span><br><span class="line">router.get(&apos;/&apos;, function(req, res, next) &#123;</span><br><span class="line">	// 要返回的数据</span><br><span class="line">	var data = &#123;</span><br><span class="line">		&quot;name&quot;: &quot;kaelyn&quot;</span><br><span class="line">	&#125;;</span><br><span class="line">	// 把json数据转化成字符串，方便字符串拼接</span><br><span class="line"> 	data = JSON.stringify(data);</span><br><span class="line">	// 拼接回调函数的字符串</span><br><span class="line"> 	var callback = req.query.callback+&apos;(&apos;+data+&apos;);&apos;;</span><br><span class="line"> 	res.end(callback);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样就实现了通过 <strong>jsonp</strong> 跨域访问：<br>&emsp;&emsp;<img src="http://img.blog.csdn.net/20171022224631863" alt="jsonp返回输出"></p>
<blockquote>
<p>&emsp;&emsp;值得注意的是，回调函数需要是全局的。<br>&emsp;&emsp;<strong>req.query.callback</strong> 获取 URL 的键名为<strong>‘callback’</strong> 的查询参数串。<br>&emsp;&emsp;关于 <strong>node.js</strong> 的 <strong>Express</strong> 框架的基本使用可以看看<a href="http://blog.csdn.net/kaelyn_x/article/details/78308245" target="_blank" rel="noopener">这里</a>。</p>
</blockquote>
<p>&emsp;&emsp;在前端除了上面的一种写法之外，还有其他写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">	function callback(data) &#123;</span><br><span class="line">	    console.log(data);</span><br><span class="line">	&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;!--直接插入一个 script 标签--&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost:3000/jsonp?callback=callback&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;还可以使用 <strong>jquery</strong> 来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">	$.ajax(&#123;</span><br><span class="line">		type:&quot;get&quot;,</span><br><span class="line">		url:&quot;http://localhost:3000/jsonp?&quot;,</span><br><span class="line">		dataType: &quot;jsonp&quot;,</span><br><span class="line">		jsonp: &quot;callback&quot;,	//在一个jsonp请求中重写回调函数的名字(key)</span><br><span class="line">		jsonpCallback:&quot;showData&quot;,	//为jsonp请求指定一个回调函数名(value)</span><br><span class="line">		async:false,</span><br><span class="line">		success:function(data)&#123;</span><br><span class="line">			console.log(data);	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在 AJAX 请求设置中，<strong>jsonp</strong> 和 <strong>jsonpCallback</strong> 选项可以不写，jquery都会帮我们写好的，默认直接回调调用请求成功后的回调函数 <strong>success</strong> 。<br>&emsp;&emsp;如果像上面的代码一样定义，则在服务端接收到的请求 URL 将会加上 <code>?&amp;callback=showData</code>，如果我们改了AJAX 请求设置中 <strong>jsonp</strong> 的值，那么服务端也需要做出一些修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var callback = req.query.callback+&apos;(&apos;+data+&apos;);&apos;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面代码中的 <code>req.query.callback</code> 要进行相应的修改，因为 URL 中的参数串的键名已经改了，如果还是原来的代码将会获取到 <strong>undefined</strong>。</p>
<blockquote>
<p>虽然是使用了 jquery 帮我们封装好的方法，但是 jsonp 和 ajax 在本质上是不一样的东西，ajax 的核心是通过 XmlHttpRequest 获取非本页内容，而 jsonp 的核心则是动态添加<code>&lt;script&gt;</code>标签来调用服务器提供的 js 脚本。</p>
</blockquote>
<hr>
<h2 id="CORS-跨源资源分享"><a href="#CORS-跨源资源分享" class="headerlink" title="CORS(跨源资源分享)"></a>CORS(跨源资源分享)</h2><p>&emsp;&emsp;<strong>CORS</strong>（Cross-origin resource sharing）是一个W3C标准，是跨源AJAX请求的<strong>根本解决方法</strong>。<br>&emsp;&emsp;在服务端启用CORS:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//设置跨域访问  </span><br><span class="line">app.all(&apos;*&apos;, function(req, res, next) &#123;  </span><br><span class="line">	res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);  </span><br><span class="line">	res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;);  </span><br><span class="line">	res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);  </span><br><span class="line">	res.header(&quot;X-Powered-By&quot;,&apos; 3.2.1&apos;)  </span><br><span class="line">	res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);  </span><br><span class="line">	next();  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>上面代码的all方法表示所有请求都必须通过该中间件，参数中的“*”表示对所有路径有效。</p>
</blockquote>
<p>&emsp;&emsp;在网页中发起 ajax 请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">	type:&quot;get&quot;,</span><br><span class="line">	url:&quot;http://localhost:3000/query&quot;,</span><br><span class="line">	dataType: &quot;json&quot;,</span><br><span class="line">	success:function(data)&#123;</span><br><span class="line">		console.log(data);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;结果当然是能成功访问啦：<br>&emsp;&emsp;<img src="http://img.blog.csdn.net/20171022224631863" alt="CORS返回输出"><br>&emsp;&emsp;可以做个比较，如果没有在服务端没有加上上面的允许其他源访问的代码，浏览器将会报错：<br>&emsp;&emsp;<img src="http://img.blog.csdn.net/20171023114753456" alt="跨域失败"><br>&emsp;&emsp;服务端返回的 <strong>Access-Control-Allow-Origin: *</strong> 表明，该资源可以被任意外域访问。如果服务端仅允许来自 <code>http://foo.example</code> 的访问，该首部字段的内容如下：<code>Access-Control-Allow-Origin: http://foo.example</code>。<br>&emsp;&emsp;如果希望允许多个域名访问，则可以这样设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">app.all(&apos;*&apos;, function(req, res, next) &#123;  </span><br><span class="line">	// 允许访问的域名列表</span><br><span class="line">	var originList = [&quot;http://localhost:8020&quot;, &quot;https://www.baidu.com&quot;, &quot;http://www.google.com&quot;];</span><br><span class="line">	// 访问的域名</span><br><span class="line">	var reqOrigin = req.headers.origin;</span><br><span class="line">	// 判断访问的域名是否在允许访问的域名列表中</span><br><span class="line">	if(!!reqOrigin &amp;&amp; originList.indexOf(reqOrigin) != -1)&#123;</span><br><span class="line">		console.log(reqOrigin);</span><br><span class="line">		res.header(&quot;Access-Control-Allow-Origin&quot;, reqOrigin);  </span><br><span class="line">		res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;);  </span><br><span class="line">		res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);  </span><br><span class="line">		res.header(&quot;X-Powered-By&quot;,&apos; 3.2.1&apos;)  </span><br><span class="line">		res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);  </span><br><span class="line">	&#125;</span><br><span class="line">	next();  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这样我们就可以通过判断访问的域名是否在我们允许的域名列表中，如果存在就允许跨域访问，否则不允许。</p>
<blockquote>
<p>&emsp;&emsp;<strong>Array.prototype.indexOf()</strong> 方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p>
</blockquote>
<blockquote>
<p>&emsp;&emsp;关于 <strong>CORS</strong> 的知识可以看看<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">这里</a>。</p>
</blockquote>
<hr>
<h2 id="CORS与JSONP比较"><a href="#CORS与JSONP比较" class="headerlink" title="CORS与JSONP比较"></a>CORS与JSONP比较</h2><ul>
<li>相比 JSONP 只能发 GET 请求，CORS 允许任何类型的请求。</li>
<li>JSONP 的优势在于支持老式浏览器（IE浏览器不能低于IE10才能兼容 CORS），以及可以向不支持 CORS 的网站请求数据。</li>
</ul>
<hr>
<h2 id="服务器代理实现跨域"><a href="#服务器代理实现跨域" class="headerlink" title="服务器代理实现跨域"></a>服务器代理实现跨域</h2><p>&emsp;&emsp;因为浏览器端的同源策略才产生了跨域问题，所以我们可以使用<strong>服务器代理</strong>的方法绕开浏览器端：前端向与自己<strong>同源的服务器</strong>发起请求，该同源服务器再向<strong>不同源的服务器</strong>发送请求（请求转发），把同源服务器请求的数据再返回给前端就大功告成了。<br>&emsp;&emsp;<img src="http://img.blog.csdn.net/20171023191638427" alt="服务器代理"></p>
<p>&emsp;&emsp;首先看看端口号为<strong>3000</strong>的 node.js 服务器的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/* GET home page. */</span><br><span class="line">router.get(&apos;/&apos;, function(req, res, next) &#123;</span><br><span class="line">	 res.sendfile(&apos;./views/proxy.html&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(&apos;/proxy&apos;, function(req, res, next) &#123;</span><br><span class="line"> 	var headers = req.headers;</span><br><span class="line">	var options = &#123;</span><br><span class="line">	    host: &apos;localhost&apos;,</span><br><span class="line">	    port: 5000,</span><br><span class="line">	    path: &apos;/query&apos;,</span><br><span class="line">	    method: &apos;GET&apos;,</span><br><span class="line">	    headers: headers	</span><br><span class="line">	&#125;;</span><br><span class="line">	// 发起 HTTP 请求</span><br><span class="line">	var req = http.request(options, function(res) &#123;</span><br><span class="line">	    res.setEncoding(&apos;utf8&apos;);</span><br><span class="line">	    res.on(&apos;data&apos;, function (data) &#123;</span><br><span class="line">		  //从端口号为5000的服务器中获取 data</span><br><span class="line">	      var data = JSON.parse(data);</span><br><span class="line">	      //获取数据后传回浏览器</span><br><span class="line">	      success(data);</span><br><span class="line">	    &#125;);</span><br><span class="line">	&#125;);	</span><br><span class="line">	req.on(&apos;error&apos;, function(e)&#123;</span><br><span class="line">	   console.log(&quot;problem with request:&quot; + e.message);</span><br><span class="line">	&#125;);</span><br><span class="line">	req.end();</span><br><span class="line">	</span><br><span class="line">	//获取数据后传回浏览器</span><br><span class="line">	function success(data)&#123;</span><br><span class="line">		res.send(data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当开始服务器后访问<code>http://localhost:3000/</code>，服务器传回一个<code>proxy.html</code>文件给浏览器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--proxy.html--&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;proxy&lt;/title&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;script src=&quot;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">		&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">			$.ajax(&#123;</span><br><span class="line">				type:&quot;get&quot;,</span><br><span class="line">				url:&quot;http://localhost:3000/proxy&quot;,</span><br><span class="line">				dataType: &quot;json&quot;,</span><br><span class="line">				success:function(data)&#123;</span><br><span class="line">					console.log(data);	</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>proxy.html</code>网页中发起 <strong>ajax 请求</strong>向<code>http://localhost:3000/proxy</code>获取数据，然后端口号为<strong>3000</strong>的服务器接受到请求后再发起 <strong>HTTP 请求</strong>获取<code>http://localhost:5000/query</code>的数据。<br>&emsp;&emsp;显然，网页和端口号为<strong>3000</strong>的服务器就是<strong>同源</strong>的，这样子 ajax 请求肯定没问题，而且因为<strong>服务器端之间不存在跨域问题</strong>，所以端口号为<strong>3000</strong>的服务器向端口号为<strong>5000</strong>的服务器发送请求也没问题。<br>&emsp;&emsp;再来看看端口号为<strong>5000</strong>的 node.js 服务器的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">router.get(&apos;/query&apos;, function(req, res, next) &#123;</span><br><span class="line">	var data = &#123;</span><br><span class="line">		&quot;name&quot;: &quot;kaelyn&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	res.json(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;就这样，当我们启动两个服务器后，打开浏览器访问<code>http://localhost:3000/</code>，就可以看到在控制台上打印出了返回的数据，这就是通过服务器代理解决跨域问题的方法。</p>
<blockquote>
<p>关于 <strong>node.js 的 http.request</strong> 方法的知识可以看看<a href="http://nodejs.cn/api/http.html#http_http_request_options_callback" target="_blank" rel="noopener">这里</a>。</p>
</blockquote>
</div><div class="tags"><a href="/tags/jsonp/">jsonp</a><a href="/tags/CORS/">CORS</a><a href="/tags/服务器代理/">服务器代理</a><a href="/tags/跨域/">跨域</a></div><div class="post-nav"><a class="pre" href="/2017/11/01/判断scroll是否滚动到底部以及实现回到顶部/">判断scroll滚动到底部以及实现回到顶部</a><a class="next" href="/2017/10/22/node.js的Express框架起步/">node.js的Express框架起步</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/">ES6</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/css3/">css3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/html5/">html5</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/node-js/">node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/questions/">questions</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue/">vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/函数参数表达/" style="font-size: 15px;">函数参数表达</a> <a href="/tags/BFC/" style="font-size: 15px;">BFC</a> <a href="/tags/css3/" style="font-size: 15px;">css3</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/绝对底部/" style="font-size: 15px;">绝对底部</a> <a href="/tags/StickyFoot/" style="font-size: 15px;">StickyFoot</a> <a href="/tags/图片压缩/" style="font-size: 15px;">图片压缩</a> <a href="/tags/canvas/" style="font-size: 15px;">canvas</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/vuex/" style="font-size: 15px;">vuex</a> <a href="/tags/action/" style="font-size: 15px;">action</a> <a href="/tags/getter/" style="font-size: 15px;">getter</a> <a href="/tags/mutation/" style="font-size: 15px;">mutation</a> <a href="/tags/state/" style="font-size: 15px;">state</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/let/" style="font-size: 15px;">let</a> <a href="/tags/const/" style="font-size: 15px;">const</a> <a href="/tags/块级作用域/" style="font-size: 15px;">块级作用域</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/node-js/" style="font-size: 15px;">node.js</a> <a href="/tags/express/" style="font-size: 15px;">express</a> <a href="/tags/promise/" style="font-size: 15px;">promise</a> <a href="/tags/element/" style="font-size: 15px;">element</a> <a href="/tags/table/" style="font-size: 15px;">table</a> <a href="/tags/tree/" style="font-size: 15px;">tree</a> <a href="/tags/upload/" style="font-size: 15px;">upload</a> <a href="/tags/mixins/" style="font-size: 15px;">mixins</a> <a href="/tags/模块化/" style="font-size: 15px;">模块化</a> <a href="/tags/定义模块/" style="font-size: 15px;">定义模块</a> <a href="/tags/引入模块/" style="font-size: 15px;">引入模块</a> <a href="/tags/暴露模块/" style="font-size: 15px;">暴露模块</a> <a href="/tags/三栏布局/" style="font-size: 15px;">三栏布局</a> <a href="/tags/圣杯布局/" style="font-size: 15px;">圣杯布局</a> <a href="/tags/双飞翼/" style="font-size: 15px;">双飞翼</a> <a href="/tags/形状/" style="font-size: 15px;">形状</a> <a href="/tags/正方形容器/" style="font-size: 15px;">正方形容器</a> <a href="/tags/图片上传/" style="font-size: 15px;">图片上传</a> <a href="/tags/padding/" style="font-size: 15px;">padding</a> <a href="/tags/Sass/" style="font-size: 15px;">Sass</a> <a href="/tags/浏览器引擎前缀/" style="font-size: 15px;">浏览器引擎前缀</a> <a href="/tags/IFC/" style="font-size: 15px;">IFC</a> <a href="/tags/函数参数传参/" style="font-size: 15px;">函数参数传参</a> <a href="/tags/scroll/" style="font-size: 15px;">scroll</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/Set/" style="font-size: 15px;">Set</a> <a href="/tags/WeakSet/" style="font-size: 15px;">WeakSet</a> <a href="/tags/Map/" style="font-size: 15px;">Map</a> <a href="/tags/WeakMap/" style="font-size: 15px;">WeakMap</a> <a href="/tags/对象字面量/" style="font-size: 15px;">对象字面量</a> <a href="/tags/无缝滚动/" style="font-size: 15px;">无缝滚动</a> <a href="/tags/模板字符串/" style="font-size: 15px;">模板字符串</a> <a href="/tags/Template-String/" style="font-size: 15px;">Template String</a> <a href="/tags/瀑布流布局/" style="font-size: 15px;">瀑布流布局</a> <a href="/tags/Generator/" style="font-size: 15px;">Generator</a> <a href="/tags/箭头函数/" style="font-size: 15px;">箭头函数</a> <a href="/tags/Arrow-Function/" style="font-size: 15px;">Arrow Function</a> <a href="/tags/class/" style="font-size: 15px;">class</a> <a href="/tags/表达式解构/" style="font-size: 15px;">表达式解构</a> <a href="/tags/multer/" style="font-size: 15px;">multer</a> <a href="/tags/文件上传/" style="font-size: 15px;">文件上传</a> <a href="/tags/html5/" style="font-size: 15px;">html5</a> <a href="/tags/离线存储/" style="font-size: 15px;">离线存储</a> <a href="/tags/appcache/" style="font-size: 15px;">appcache</a> <a href="/tags/继承/" style="font-size: 15px;">继承</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/垃圾回收机制/" style="font-size: 15px;">垃圾回收机制</a> <a href="/tags/proxy/" style="font-size: 15px;">proxy</a> <a href="/tags/自定义行为/" style="font-size: 15px;">自定义行为</a> <a href="/tags/Symbol/" style="font-size: 15px;">Symbol</a> <a href="/tags/clock/" style="font-size: 15px;">clock</a> <a href="/tags/FileReader/" style="font-size: 15px;">FileReader</a> <a href="/tags/图片预览/" style="font-size: 15px;">图片预览</a> <a href="/tags/标签页间通信/" style="font-size: 15px;">标签页间通信</a> <a href="/tags/shadowDOM/" style="font-size: 15px;">shadowDOM</a> <a href="/tags/影子根/" style="font-size: 15px;">影子根</a> <a href="/tags/影子宿主/" style="font-size: 15px;">影子宿主</a> <a href="/tags/jsonp/" style="font-size: 15px;">jsonp</a> <a href="/tags/CORS/" style="font-size: 15px;">CORS</a> <a href="/tags/服务器代理/" style="font-size: 15px;">服务器代理</a> <a href="/tags/跨域/" style="font-size: 15px;">跨域</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/09/hexo-theme/">hexo-theme</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/09/hello-world/">hello-world</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/Vuex的Mutation学习/">Vuex 的 Mutation 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/Vuex的Action学习/">Vuex 的 Action 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/25/Vuex的Getter学习/">Vuex 的 Getter 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/24/Vuex的State学习/">Vuex 的 State 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/23/vue的混合mixins学习/">vue的混合mixins学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/28/vue+element的upload组件学习模板/">vue+element的upload组件学习模板</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/28/vue+element的tree组件学习模板/">vue+element的tree组件学习模板</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/vue+element的table组件学习模板/">vue+element的table组件学习模板</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">kaelyn.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>