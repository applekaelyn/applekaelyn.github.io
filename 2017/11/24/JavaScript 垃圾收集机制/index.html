<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>JavaScript 垃圾收集机制 | kaelyn</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JavaScript 垃圾收集机制</h1><a id="logo" href="/.">kaelyn</a><p class="description">kaelyn's blog</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JavaScript 垃圾收集机制</h1><div class="post-meta">Nov 24, 2017<span> | </span><span class="category"><a href="/categories/javascript/">javascript</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#标记清除"><span class="toc-number">1.</span> <span class="toc-text">标记清除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引用计数"><span class="toc-number">2.</span> <span class="toc-text">引用计数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性能问题"><span class="toc-number">3.</span> <span class="toc-text">性能问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#管理内存"><span class="toc-number">4.</span> <span class="toc-text">管理内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a></li></ol></div></div><div class="post-content"><p>&emsp;&emsp;JavaScript 具有<strong>自动垃圾收集机制</strong>，也就是说，执行环境会负责管理代码执行过程中使用的内存。而在 C 和 C++之类的语言中，开发人员的一项基本任务就是<strong>手工跟踪内存的使用情况</strong>，这是造成许多问题的一个根源。在编写 JavaScript 程序时，开发人员不用再关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了<strong>自动管理</strong>。这种垃圾收集机制的原理其实很简单：<strong>找出那些不再继续使用的变量，然后释放其占用的内存。</strong>为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），<strong>周期性</strong>地执行这一操作。<br>&emsp;&emsp;下面我们来分析一下函数中局部变量的正常生命周期。<strong>局部变量</strong>只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上<strong>分配</strong>相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以<strong>释放</strong>它们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但并非所有情况下都这么容易就能得出结论。垃圾收集器必须<strong>跟踪</strong>哪个变量有用哪个变量没用，对于不再有用的变量<strong>打上标记</strong>，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有<strong>两个策略</strong>。</p>
<hr>
<h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>&emsp;&emsp;JavaScript 中最常用的垃圾收集方式是<strong>标记清除（mark-and-sweep）</strong>。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为<strong>“进入环境”</strong>。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为<strong>“离开环境”</strong>。<br>&emsp;&emsp;可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。说到底，如何标记变量其实并不重要，关键在于采取什么策略。<br>&emsp;&emsp;垃圾收集器在运行的时候会给存储在内存中的所有变量都加上<strong>标记</strong>（当然，可以使用任何标记方式）。然后，它会<strong>去掉环境中的变量以及被环境中的变量引用的变量的标记</strong>。而在此之后再被加上标记的变量将被视为<strong>准备删除的变量</strong>，原因是环境中的变量已经<strong>无法访问</strong>到这些变量了。最后，垃圾收集器完成内存清除工作，<strong>销毁</strong>那些带标记的值并<strong>回收</strong>它们所占用的内存空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line"> var a = 1; // 被标记，进入环境 </span><br><span class="line"> var b = 2; // 被标记，进入环境</span><br><span class="line">&#125;</span><br><span class="line">test(); // 执行完毕之后 a、b又被标离开环境，被回收。</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>&emsp;&emsp;另一种不太常见的垃圾收集策略叫做<strong>引用计数（reference counting）</strong>。引用计数的含义是<strong>跟踪记录每个值被引用的次数</strong>。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数<strong>加 1</strong>。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数<strong>减 1</strong>。当这个值的<strong>引用次数变成 0</strong> 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间<strong>回收</strong>回来。这样，当垃圾收集器下次再运行时，它就会<strong>释放</strong>那些引用次数为零的值所占用的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line"> var a = &#123;&#125;; // a的引用次数为0 </span><br><span class="line"> var b = a;  // a的引用次数加1，为1 </span><br><span class="line"> var c = a;    // a的引用次数再加1，为2</span><br><span class="line"> var b = &#123;&#125;;   // a的引用次数减1，为1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Netscape Navigator 3.0是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：<strong>循环引用</strong>。循环引用指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用。请看下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">	var a = &#123;&#125;;</span><br><span class="line">	var b = &#123;&#125;;</span><br><span class="line">	a.someOtherObject = b;</span><br><span class="line">	b.anotherObject = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这个例子中， a 和 b 通过各自的属性相互引用；也就是说，这两个对象的引用次数都是 2。在采用<strong>标记清除策略</strong>的实现中，由于函数执行之后，这两个对象都<strong>离开了作用域</strong>，因此这种相互引用不是个问题。但在采用引用<strong>计数策略</strong>的实现中，当函数执行完毕后， a 和 b 还将继续存在，因为它们的引用次数<strong>永远不会是 0</strong>。假如这个函数被重复多次调用，就会导致大量内存得不到回收。为此，Netscape 在 Navigator 4.0 中放弃了引用计数方式，转而采用标记清除来实现其垃圾收集机制。可是，引用计数导致的麻烦并未就此终结。<br>&emsp;&emsp;我们知道，IE 中有一部分对象并不是原生 JavaScript 对象。例如，其 BOM 和 DOM 中的对象就是使用 C++以 <strong>COM（Component Object Model，组件对象模型）对象</strong>的形式实现的，而 COM 对象的垃圾收集机制采用的就是<strong>引用计数策略</strong>。因此，即使 IE 的 JavaScript 引擎是使用标记清除策略来实现的，但JavaScript 访问的 COM 对象依然是基于引用计数策略的。换句话说，<strong>只要在 IE 中涉及 COM 对象，就会存在循环引用的问题</strong>。下面这个简单的例子，展示了使用 COM 对象导致的循环引用问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var element = document.getElementById(&quot;some_element&quot;);</span><br><span class="line">var myObject = new Object();</span><br><span class="line">myObject.element = element;</span><br><span class="line">element.someObject = myObject;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个例子在一个 DOM 元素（ element ）与一个原生 JavaScript 对象（ myObject ）之间创建了<strong>循环引用</strong>。其中，变量 myObject 有一个名为 element 的属性指向 element 对象；而变量 element 也有一个属性名叫 someObject 回指 myObject 。由于存在这个循环引用，即使将例子中的 DOM 从页面中移除，它也<strong>永远不会被回收</strong>。<br>&emsp;&emsp;为了避免类似这样的循环引用问题，最好是在不使用它们的时候手工断开原生 JavaScript 对象与DOM 元素之间的连接。例如，可以使用下面的代码消除前面例子创建的循环引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myObject.element = null;</span><br><span class="line">element.someObject = null;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将变量设置为 null 意味着<strong>切断</strong>变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。<br>&emsp;&emsp;为了解决上述问题，IE9 把 BOM 和 DOM 对象都转换成了真正的 JavaScript 对象。这样，就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。</p>
<hr>
<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>&emsp;&emsp;垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，<strong>确定垃圾收集的时间间隔</strong>是一个非常重要的问题。说到垃圾收集器多长时间运行一次，不禁让人联想到 IE 因此而声名狼藉的性能问题。IE 的垃圾收集器是根据内存分配量运行的，具体一点说就是 256 个变量、4096 个对象（或数组）字面量和数组元素（slot）或者 64KB 的字符串。达到上述任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收集器就不得不频繁地运行。结果，由此引发的严重性能问题促使 IE7 重写了其垃圾收集例程。<br>&emsp;&emsp;随着 IE7 的发布，其 JavaScript 引擎的垃圾收集例程改变了工作方式：<strong>触发垃圾收集的变量分配、字面量和（或）数组元素的临界值被调整为动态修正</strong>。IE7 中的各项临界值在初始时与 IE6 相等。如果垃圾收集例程回收的内存分配量低于 15%，则变量、字面量和（或）数组元素的临界值就会加倍。如果例程回收了 85%的内存分配量，则将各种临界值重置回默认值。这一看似简单的调整，极大地提升了 IE在运行包含大量 JavaScript 的页面时的性能。</p>
<blockquote>
<p>事实上，在有的浏览器中可以触发垃圾收集过程，但不建议这样做。在IE 中，调用 <strong>window.CollectGarbage()</strong> 方法会立即执行垃圾收集。在 Opera 7 及更高版本中，调用 <strong>window.opera.collect()</strong> 也会启动垃圾收集例程。</p>
</blockquote>
<hr>
<h2 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h2><p>&emsp;&emsp;我们知道，计算机分配给 Web 浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃。<strong>内存限制</strong>问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。<br>&emsp;&emsp;因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是<strong>为执行中的代码只保存必要的数据</strong>。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做<strong>解除引用（dereferencing）</strong>。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用，如下面这个例子所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name)&#123;</span><br><span class="line">	var localPerson = new Object();</span><br><span class="line">	localPerson.name = name;</span><br><span class="line">	return localPerson;</span><br><span class="line">&#125;</span><br><span class="line">var globalPerson = createPerson(&quot;kobe&quot;);</span><br><span class="line">// 手工解除 globalPerson 的引用</span><br><span class="line">globalPerson = null;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是<strong>让值脱离执行环境</strong>，以便垃圾收集器下次运行时将其回收。</p>
<hr>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><strong>离开作用域的值将被自动标记为可以回收</strong>，因此将在垃圾收集期间被删除。</li>
<li><strong>“标记清除”</strong>是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。</li>
<li>另一种垃圾收集算法是<strong>“引用计数”</strong>，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript 引擎目前都不再使用这种算法；但在 IE 中访问非原生 JavaScript 对象（如 DOM 元素）时，这种算法仍然可能会导致问题。</li>
<li>当代码中存在<strong>循环引用</strong>现象时，“引用计数”算法就会导致问题。</li>
<li><strong>解除变量的引用</strong>不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。</li>
</ul>
</div><div class="tags"><a href="/tags/javascript/">javascript</a><a href="/tags/垃圾回收机制/">垃圾回收机制</a></div><div class="post-nav"><a class="pre" href="/2017/11/25/JavaScript 六种继承方式/">JavaScript 六种继承方式</a><a class="next" href="/2017/11/23/神奇的Shadow DOM/">神奇的Shadow DOM</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/">ES6</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/css3/">css3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/html5/">html5</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/node-js/">node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/questions/">questions</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue/">vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/函数参数表达/" style="font-size: 15px;">函数参数表达</a> <a href="/tags/css3/" style="font-size: 15px;">css3</a> <a href="/tags/IFC/" style="font-size: 15px;">IFC</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/绝对底部/" style="font-size: 15px;">绝对底部</a> <a href="/tags/StickyFoot/" style="font-size: 15px;">StickyFoot</a> <a href="/tags/图片压缩/" style="font-size: 15px;">图片压缩</a> <a href="/tags/canvas/" style="font-size: 15px;">canvas</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/vuex/" style="font-size: 15px;">vuex</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/09/hello-world/">hello-world</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/09/hexo-theme/">hexo-theme</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/Vuex的Mutation学习/">Vuex 的 Mutation 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/Vuex的Action学习/">Vuex 的 Action 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/25/Vuex的Getter学习/">Vuex 的 Getter 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/24/Vuex的State学习/">Vuex 的 State 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/23/vue的混合mixins学习/">vue的混合mixins学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/28/vue+element的upload组件学习模板/">vue+element的upload组件学习模板</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/28/vue+element的tree组件学习模板/">vue+element的tree组件学习模板</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/vue+element的table组件学习模板/">vue+element的table组件学习模板</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">kaelyn.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>