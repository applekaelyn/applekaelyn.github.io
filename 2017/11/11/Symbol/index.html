<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>ES6之Symbol | kaelyn</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ES6之Symbol</h1><a id="logo" href="/.">kaelyn</a><p class="description">kaelyn's blog</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ES6之Symbol</h1><div class="post-meta">Nov 11, 2017<span> | </span><span class="category"><a href="/categories/ES6/">ES6</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本语法"><span class="toc-number">1.</span> <span class="toc-text">基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#生成唯一的-Symbol-值"><span class="toc-number">1.1.</span> <span class="toc-text">生成唯一的 Symbol 值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注册全局可重用-Symbol"><span class="toc-number">1.2.</span> <span class="toc-text">注册全局可重用 Symbol</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取全局-Symbol-的-key"><span class="toc-number">1.3.</span> <span class="toc-text">获取全局 Symbol 的 key</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用-Symbol-值"><span class="toc-number">2.</span> <span class="toc-text">常用 Symbol 值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iterator"><span class="toc-number">3.</span> <span class="toc-text">iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hasInstance"><span class="toc-number">4.</span> <span class="toc-text">hasInstance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#match"><span class="toc-number">5.</span> <span class="toc-text">match</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unscopables"><span class="toc-number">6.</span> <span class="toc-text">unscopables</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#toPrimitive"><span class="toc-number">7.</span> <span class="toc-text">toPrimitive</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#toStringTag"><span class="toc-number">8.</span> <span class="toc-text">toStringTag</span></a></li></ol></div></div><div class="post-content"><p>&emsp;&emsp;Symbol 是一种<strong>互不等价的标志</strong>，字面量对象除了可以使用字符串、数字作为属性键以外，还可以使用 Symbol 作为属性键，因此便可以利用 Symbol 值的互不等价特性来实现属性操作的互不干扰。</p>
<hr>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="生成唯一的-Symbol-值"><a href="#生成唯一的-Symbol-值" class="headerlink" title="生成唯一的 Symbol 值"></a>生成唯一的 Symbol 值</h3><p>&emsp;&emsp;执行 <strong>Symbol([description]) 函数</strong>可以生成一个与其他 Symbol 值互不等价的 Symbol 值，其中 Symbol() 函数可以接受一个除 Symbol 值以外的值作为该 Symbol 值的<strong>描述</strong>，以便通过开发者的辨认判断其为可选的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const symbol = Symbol();	// Symbol()</span><br><span class="line">const symbolForSomething = Symbol(&apos;something&apos;);		// Symbol(something)</span><br><span class="line">const symbolWithNumber = Symbol(3.14);		// Symbol(3.14)</span><br><span class="line">const symbolWithObject = Symbol(&#123;&apos;foo&apos;: &apos;bar&apos;&#125;);	// Symbol([object Object])</span><br><span class="line"></span><br><span class="line">// Don&apos;t use a symbol to be another symbol&apos;s description</span><br><span class="line">const anotherSymbol = Symbol(symbol);	// Uncaught TypeError: Cannot convert a Symbol value to a string</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;需要注意的是，<strong>我们设定的描述仅仅是起到了描述的作用</strong>，而不会对 Symbol 值本身起到任何的改变作用，因此，即使是两个具有相同描述值的 Symbol 值也并<strong>不具有</strong>等价性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const symbol1 = Symbol(&apos;foo&apos;);</span><br><span class="line">const symbol2 = Symbol(&apos;foo&apos;);</span><br><span class="line"></span><br><span class="line">symbol1 == symbol2;	// false</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;还要非常注意的一点是， <strong>Symbol 函数并不是一个构造函数</strong>，所以开发者<strong>不能</strong>使用 new 语句来生成一个 Symbol “对象”，否则将会抛出一个 TypeError 错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Symbol();	// Uncaught TypeError: Symbol is not a constructor</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;由此可知，<strong>Symbol 是一种值类型而非引用类型</strong>，这就意味着如果将 Symbol 值作为函数形参进行传递，将会进行<strong>复制值传递</strong>而非引用传递，这跟其他值类型（字符串、数字等）的行为是一致的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const symbol = Symbol(&apos;hello&apos;);</span><br><span class="line"></span><br><span class="line">function fn1(_symbol)&#123;</span><br><span class="line">	return _symbol == symbol;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(fn1(symbol));  	// true</span><br><span class="line"></span><br><span class="line">function fn2(_symbol)&#123;</span><br><span class="line">	_symbol = null;</span><br><span class="line">	console.log(_symbol);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn2(symbol); 		// null</span><br><span class="line">console.log(symbol);   // Symbol(hello)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当然，如果真的希望得到一个 Symbol “对象”，可以使用 <strong>Object() 函数</strong>实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const symbol = Symbol(&apos;foo&apos;);</span><br><span class="line">typeof symbol;   // symbol</span><br><span class="line">const symbolObj = Object(symbol);</span><br><span class="line">typeof symbolObj;  // object</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="注册全局可重用-Symbol"><a href="#注册全局可重用-Symbol" class="headerlink" title="注册全局可重用 Symbol"></a>注册全局可重用 Symbol</h3><p>&emsp;&emsp;开发者可以通过一个 <strong>key</strong> 向当前运行时注册一个需要在其他程序中使用的 Symbol：<code>Symbol.for([key]) : Symbol</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cosnt symbol = Symbol.for(&apos;foo&apos;);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Symbol.for() 与 Symbol() 区别是，<strong>Symbol.for()</strong> 会根据传入的 key 在<strong>全局作用域</strong>中注册一个 Symbol 值，如果某一个 key 从未被注册到全局作用域中，便会<strong>创建</strong>一个 Symbol 值并根据 key 注册到全局环境中，如果该 key 已被注册，就会<strong>返回</strong>一个与第一次使用创建的 Symbol 的值<strong>等价</strong>的 Symbol 值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const symbol = Symbol.for(&apos;foo&apos;);</span><br><span class="line">const obj = &#123;&#125;;</span><br><span class="line">obj[symbol] = &apos;bar&apos;;</span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">const anotherSymbol = Symbol.for(&apos;foo&apos;);</span><br><span class="line"></span><br><span class="line">console.log(symbol === anotherSymbol);	// true</span><br><span class="line">console.log(obj[anotherSymbol]);  // bar</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="获取全局-Symbol-的-key"><a href="#获取全局-Symbol-的-key" class="headerlink" title="获取全局 Symbol 的 key"></a>获取全局 Symbol 的 key</h3><p>&emsp;&emsp;用法：<code>Symbol.keyFor(&lt;global symbol&gt;) : String</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const symbol = Symbol.for(&apos;foo&apos;);</span><br><span class="line">console.log(Symbol.keyFor(symbol));  // foo</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="常用-Symbol-值"><a href="#常用-Symbol-值" class="headerlink" title="常用 Symbol 值"></a>常用 Symbol 值</h2><table>
<thead>
<tr>
<th style="text-align:center">定义名</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">@@iterator</td>
<td style="text-align:center">“Symbol.iterator”</td>
<td style="text-align:center">用于为对象定义一个方法并返回一个属于所对应对象的迭代器。该迭代器会被 for-of 循环语句所使用</td>
</tr>
<tr>
<td style="text-align:center">@@hasInstance</td>
<td style="text-align:center">“Symbol.hasInstance”</td>
<td style="text-align:center">用于为类定义一个方法。该方法会因为 instanceof 语句的使用而被调用，来检查一个对象是否是某一个类的实例</td>
</tr>
<tr>
<td style="text-align:center">@@match</td>
<td style="text-align:center">“Symbol.match”</td>
<td style="text-align:center">用于为正则表达式定义一个可被 String.prototype.match() 方法使用的方法，检查对应的字符串与当前正则表达式是否匹配</td>
</tr>
<tr>
<td style="text-align:center">@@replace</td>
<td style="text-align:center">“Symbol.replace”</td>
<td style="text-align:center">用于为正则表达式或对象定义一个方法。该方法会因为 String.prototype.replace() 方法的使用而被调用，用于处理当前字符串使用该正则表达式或对象作为替换标志时的内部处理逻辑</td>
</tr>
<tr>
<td style="text-align:center">@@match</td>
<td style="text-align:center">“Symbol.match”</td>
<td style="text-align:center">用于为正则表达式定义一个可被 String.prototype.match() 方法使用的方法，检查对应的字符串与当前正则表达式是否匹配</td>
</tr>
<tr>
<td style="text-align:center">@@search</td>
<td style="text-align:center">“Symbol.search”</td>
<td style="text-align:center">用于为正则表达式或对象定义一个方法。该方法会因为 String.prototype.search() 方法的使用而被调用，用于处理当前字符串使用该正则表达式或对象作为位置检索标志时的内部处理逻辑</td>
</tr>
<tr>
<td style="text-align:center">@@split</td>
<td style="text-align:center">“Symbol.split”</td>
<td style="text-align:center">用于为正则表达式或对象定义一个方法。该方法会因为 String.prototype.split() 方法的使用而被调用，用于处理当前字符串使用该正则表达式或对象作为分割标志时的内部处理逻辑</td>
</tr>
<tr>
<td style="text-align:center">@@unscopables</td>
<td style="text-align:center">“Symbol.unscopables”</td>
<td style="text-align:center">用于为对象定义一个属性，该属性用于描述该对象中哪些属性时可以被 with 语句所使用的</td>
</tr>
<tr>
<td style="text-align:center">@@isConcatSpreadable</td>
<td style="text-align:center">“Symbol.isConcatSpreadable”</td>
<td style="text-align:center">用于为对象定义一个属性，该属性用于决定该对象作为 Array.prototype.concat() 方法的参数时，是否会被展开</td>
</tr>
<tr>
<td style="text-align:center">@@species</td>
<td style="text-align:center">“Symbol.species”</td>
<td style="text-align:center">用于为类定义一个静态属性，该属性用于决定该类的默认构建函数</td>
</tr>
<tr>
<td style="text-align:center">@@toPrimitive</td>
<td style="text-align:center">“Symbol.toPrimitive”</td>
<td style="text-align:center">用于为对象定义一个方法，该方法会在该对象需要转换为值类型的时候被调用可以根据程序的行为决定该对象需要被转换成的值</td>
</tr>
<tr>
<td style="text-align:center">@@toStringTag</td>
<td style="text-align:center">“Symbol.toStringTag”</td>
<td style="text-align:center">用于为类定义一个属性，该属性可以决定这个类的实例在调用 toString() 方法时，其中的标签内容</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><p>&emsp;&emsp;在 ES6 中定义了<strong>可迭代对象(Iterable Object)</strong>和新的 <strong>for-of 循环语句</strong>，其中可迭代对象<strong>并不是</strong>一种类型，而是带有<strong>@@iterator 属性</strong>和<strong>可以被 for-of 循环语句所遍历的对象</strong>的统称。<br>&emsp;&emsp;ES6 中默认的<strong>可迭代对象</strong>有: <strong>数组(Array)</strong>、<strong>字符串(String)</strong>、<strong>类型数组(TypedArray)</strong>、<strong>映射对象(Map)</strong>、<strong>集合对象(Set)</strong>和<strong>生成器实例(Generator)</strong>，而在浏览器的运行环境中，<strong>DOM 元素集合</strong>(如 <strong>NodeList</strong>) 也是可迭代对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Array</span><br><span class="line">for(const el of [1, 2, 3]) console.log(el);</span><br><span class="line">// String</span><br><span class="line">for(const word of &apos;hello world&apos;) console.log(word);</span><br><span class="line">// TypedArray</span><br><span class="line">for(const value of new Uint8Array([0x00, 0xff])) console.log(value);</span><br><span class="line">// Map</span><br><span class="line">for(const entry of new Map([[&apos;a&apos;, 1], [&apos;b&apos;, 2]])) console.log(entry);</span><br><span class="line">// Set</span><br><span class="line">for(const el of new Set([1, 2, 3, 3, 3])) console.log(el);</span><br><span class="line">// Generator</span><br><span class="line">function* fn()&#123; yield 1; &#125;</span><br><span class="line">for(const value of fn()) console.log(value);</span><br></pre></td></tr></table></figure>
<p><br><br>&emsp;&emsp;可迭代对象都会有一个使用 <strong>Symbol.iterator</strong> 作为方法名的属性，该方法会<strong>返回一个迭代器(Iterator)</strong>。把迭代器看作一种协议，即迭代器协议(Iterator Protocol)，该协议定义了一个方法 <strong>next()</strong>，含义是<strong>进入下一次迭代的迭代状态</strong>，第一次执行返回第一次的迭代状态，该迭代状态对象需要带有两个<strong>属性</strong>。</p>
<p><center><strong>迭代状态对象属性</strong></center><br>| 属性 | 类型 | 含义 |<br>| :————-: |:————-:| :—–:|<br>| done | Boolean | 该迭代器是否已经迭代结束 |<br>| value | Any | 当前迭代状态的值 |<br>&emsp;&emsp;利用 Symbol.iterator 在对象中实现一个迭代器需要将 <strong>Symbol.iterator</strong> 作为属性键，<strong>定义一个方法</strong>。<br>&emsp;&emsp;实现单向链表：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Item&#123;</span><br><span class="line">	constructor(value, prev = null, next = null)&#123;</span><br><span class="line">		this.value = value;</span><br><span class="line">		this.next = next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	get hasNext()&#123; return !!this.next&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LinkedList&#123;</span><br><span class="line">	constructor(iterable)&#123; /* ... */&#125;</span><br><span class="line">	push(value)&#123; /* ... */&#125;</span><br><span class="line">	pop()&#123; /* ... */&#125;</span><br><span class="line">	// ...</span><br><span class="line">	get length()&#123; /* ... */&#125;</span><br><span class="line">	get head()&#123; /* ... */&#125;</span><br><span class="line">	get tail()&#123; /* ... */&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;为其定义相关方法，使其支持 <strong>for-of 循环语句</strong>的迭代，首先为链表类添加一个以 Symbol.iterator 为属性键的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class LinkedList&#123;</span><br><span class="line">	[Symbol.iterator]()&#123;</span><br><span class="line">		// ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;假设我们需要让链表对象在 for-of 循环语句中是<strong>顺序遍历</strong>的，那么就可以将每一个元素都作为迭代器的一个<strong>状态</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[Symbol.iterator]()&#123;</span><br><span class="line">	let currItem = &#123;next: this.head&#125;</span><br><span class="line">	</span><br><span class="line">	return &#123;</span><br><span class="line">		next()&#123;</span><br><span class="line">			currItem = currItem.next;</span><br><span class="line">			currItem.next = currItem.next || &#123;hasNext: false&#125;</span><br><span class="line">			</span><br><span class="line">			return &#123;</span><br><span class="line">				value: currItem.value,</span><br><span class="line">				done: !currItem.hasNext</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此处需要注意的是，迭代器需要<strong>以一个空状态作为结束标志</strong>，也就是说即使迭代器遍历到了需要输出的最后一个元素，其所对应的状态依然是未结束状态(done: false)，所以最后需要再输出一个空状态来表示结束。</p>
</blockquote>
<hr>
<h2 id="hasInstance"><a href="#hasInstance" class="headerlink" title="hasInstance"></a>hasInstance</h2><p>&emsp;&emsp;<strong>Symbol.hasInstance</strong> 为开发者提供了可以用于<strong>扩展 instanceof 语句内部逻辑</strong>的权限，开发者可以将其作为属性键，用于为一个类定义<strong>静态方法</strong>，该方法的第一个形参便是被检测的对象，而该方法的返回值便是决定了当次 instanceof 语句的返回结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">	static [Symbol.hasInstance](obj)&#123;</span><br><span class="line">		console.log(obj);  // &#123;&#125;</span><br><span class="line">		</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&#123;&#125; instanceof Foo);  // true</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><p>&emsp;&emsp;开发者可以通过 <strong>Symbol.match</strong> 来自行实现 <strong>match() 方法的运行逻辑</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const re = /foo/;</span><br><span class="line">re[Symbol.match] = function(str)&#123;</span><br><span class="line">	const regexp = this;</span><br><span class="line">	console.log(str);  // bar</span><br><span class="line">	// ...</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&apos;bar&apos;.match(re);	// true</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="unscopables"><a href="#unscopables" class="headerlink" title="unscopables"></a>unscopables</h2><p>&emsp;&emsp;<strong>with 语句</strong>的作用是将一个对象变成一段代码的上下文，在这段代码中变量或者表达式的寻找都会先从这个对象的属性开始，但有些方法是不能被 with 语句所展开的，也就是说不能被 with 语句所包含的代码检索到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">with(arr)&#123;</span><br><span class="line">	console.log(slice(0, 3));	// [1, 2, 3]</span><br><span class="line">	console.log(entries());	// ReferenceError: entries is no defined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;能不能被检索到都是通过 <strong>Symbol.unscopables</strong> 作为属性键所定义的，我们可以尝试着把 Array 类型的 entries 方法设置为 false（为 true 表示该属性禁止在 with 语句中被使用）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">arr[Symbol.unscopables].entries = false;</span><br><span class="line"></span><br><span class="line">with(arr)&#123;</span><br><span class="line">	console.log(entries());  //  ArrayIterator &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这也可以用在开发者自<strong>行创建的对象</strong>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const data = &#123;</span><br><span class="line">	foo: 1,</span><br><span class="line">	bar: 2,</span><br><span class="line">	something:3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const something = &apos;boom&apos;;</span><br><span class="line"></span><br><span class="line">data[Symbol.unscopables] = &#123;</span><br><span class="line">	foo: true,</span><br><span class="line">	bar: false,</span><br><span class="line">	something: true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">with(data)&#123;</span><br><span class="line">	console.log(bar);   // 2</span><br><span class="line">	console.log(something);  // boom</span><br><span class="line">	console.log(foo);   // ReferenceError: foo is no defined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="toPrimitive"><a href="#toPrimitive" class="headerlink" title="toPrimitive"></a>toPrimitive</h2><p>&emsp;&emsp;<strong>Symbol.toPrimitive</strong> 提供给开发者<strong>自定义处理引用类型的对象转化为值类型</strong>的控制。<br>&emsp;&emsp;开发者可以使用 Symbol.toPrimitive 作为属性键为对象定义一个方法，这个方法接受一个参数，这个参数用于<strong>判断当前隐式转换的目标类型</strong>。</p>
<p><center><strong>隐式转换参数值与对应类型</strong></center><br>| 参数值 | 含义 |<br>| :————-: |:————-:|<br>| number | 该次隐式转换的目标类型为数字 |<br>| string | 该次隐式转换的目标类型为字符串 |<br>| default | 引擎无法判断该次目标类型 |<br>&emsp;&emsp;需要注意的式，这里的 <strong>default</strong> 并不是因为目标类型无法被转换，而是因为语法上容易造成混乱，比如： 10 + obj + “” ，处于严谨，在 ES6 中被定义为 default ，由开发者<strong>自行决定</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;;</span><br><span class="line">console.log(+obj);	// Nan</span><br><span class="line">console.log(`$&#123;obj&#125;`);	// [object Object]</span><br><span class="line">console.log(obj + &quot;&quot;);	// [object Object]</span><br><span class="line"></span><br><span class="line">const Ten = &#123;</span><br><span class="line">	[Symbol.toPrimitive](hint)&#123;</span><br><span class="line">		switch(hint)&#123;</span><br><span class="line">			case &apos;number&apos;: return 10;</span><br><span class="line">			case &apos;string&apos;: return &apos;Ten&apos;;</span><br><span class="line">			case &apos;default&apos;: return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(+Ten);	// true</span><br><span class="line">console.log(`$&#123;Ten&#125;`);	// Ten</span><br><span class="line">console.log(Ten + &quot;&quot;);	// true</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="toStringTag"><a href="#toStringTag" class="headerlink" title="toStringTag"></a>toStringTag</h2><p>&emsp;&emsp;<strong>Symbol.toStringTag</strong> 的作用式可以决定这个类的实例在调用 <strong>toString() 方法</strong>时的标签内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Bar&#123;&#125;;</span><br><span class="line"></span><br><span class="line">class Foo&#123;</span><br><span class="line">	get [Symbol.toStringTag]()&#123; return &apos;bar&apos;; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj = new Foo();</span><br><span class="line">console.log(obj.toString());  // [object Bar]</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/Symbol/">Symbol</a></div><div class="post-nav"><a class="pre" href="/2017/11/13/Proxy/">ES6之Proxy</a><a class="next" href="/2017/11/10/代码模块化/">ES6之代码模块化</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/">ES6</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/css3/">css3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/html5/">html5</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/node-js/">node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/questions/">questions</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue/">vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/函数参数表达/" style="font-size: 15px;">函数参数表达</a> <a href="/tags/BFC/" style="font-size: 15px;">BFC</a> <a href="/tags/css3/" style="font-size: 15px;">css3</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/绝对底部/" style="font-size: 15px;">绝对底部</a> <a href="/tags/StickyFoot/" style="font-size: 15px;">StickyFoot</a> <a href="/tags/图片压缩/" style="font-size: 15px;">图片压缩</a> <a href="/tags/canvas/" style="font-size: 15px;">canvas</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/vuex/" style="font-size: 15px;">vuex</a> <a href="/tags/action/" style="font-size: 15px;">action</a> <a href="/tags/getter/" style="font-size: 15px;">getter</a> <a href="/tags/mutation/" style="font-size: 15px;">mutation</a> <a href="/tags/state/" style="font-size: 15px;">state</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/let/" style="font-size: 15px;">let</a> <a href="/tags/const/" style="font-size: 15px;">const</a> <a href="/tags/块级作用域/" style="font-size: 15px;">块级作用域</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/node-js/" style="font-size: 15px;">node.js</a> <a href="/tags/express/" style="font-size: 15px;">express</a> <a href="/tags/promise/" style="font-size: 15px;">promise</a> <a href="/tags/element/" style="font-size: 15px;">element</a> <a href="/tags/table/" style="font-size: 15px;">table</a> <a href="/tags/tree/" style="font-size: 15px;">tree</a> <a href="/tags/upload/" style="font-size: 15px;">upload</a> <a href="/tags/mixins/" style="font-size: 15px;">mixins</a> <a href="/tags/模块化/" style="font-size: 15px;">模块化</a> <a href="/tags/定义模块/" style="font-size: 15px;">定义模块</a> <a href="/tags/引入模块/" style="font-size: 15px;">引入模块</a> <a href="/tags/暴露模块/" style="font-size: 15px;">暴露模块</a> <a href="/tags/三栏布局/" style="font-size: 15px;">三栏布局</a> <a href="/tags/圣杯布局/" style="font-size: 15px;">圣杯布局</a> <a href="/tags/双飞翼/" style="font-size: 15px;">双飞翼</a> <a href="/tags/形状/" style="font-size: 15px;">形状</a> <a href="/tags/正方形容器/" style="font-size: 15px;">正方形容器</a> <a href="/tags/图片上传/" style="font-size: 15px;">图片上传</a> <a href="/tags/padding/" style="font-size: 15px;">padding</a> <a href="/tags/Sass/" style="font-size: 15px;">Sass</a> <a href="/tags/浏览器引擎前缀/" style="font-size: 15px;">浏览器引擎前缀</a> <a href="/tags/IFC/" style="font-size: 15px;">IFC</a> <a href="/tags/函数参数传参/" style="font-size: 15px;">函数参数传参</a> <a href="/tags/scroll/" style="font-size: 15px;">scroll</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/Set/" style="font-size: 15px;">Set</a> <a href="/tags/WeakSet/" style="font-size: 15px;">WeakSet</a> <a href="/tags/Map/" style="font-size: 15px;">Map</a> <a href="/tags/WeakMap/" style="font-size: 15px;">WeakMap</a> <a href="/tags/对象字面量/" style="font-size: 15px;">对象字面量</a> <a href="/tags/无缝滚动/" style="font-size: 15px;">无缝滚动</a> <a href="/tags/模板字符串/" style="font-size: 15px;">模板字符串</a> <a href="/tags/Template-String/" style="font-size: 15px;">Template String</a> <a href="/tags/瀑布流布局/" style="font-size: 15px;">瀑布流布局</a> <a href="/tags/Generator/" style="font-size: 15px;">Generator</a> <a href="/tags/箭头函数/" style="font-size: 15px;">箭头函数</a> <a href="/tags/Arrow-Function/" style="font-size: 15px;">Arrow Function</a> <a href="/tags/class/" style="font-size: 15px;">class</a> <a href="/tags/表达式解构/" style="font-size: 15px;">表达式解构</a> <a href="/tags/multer/" style="font-size: 15px;">multer</a> <a href="/tags/文件上传/" style="font-size: 15px;">文件上传</a> <a href="/tags/html5/" style="font-size: 15px;">html5</a> <a href="/tags/离线存储/" style="font-size: 15px;">离线存储</a> <a href="/tags/appcache/" style="font-size: 15px;">appcache</a> <a href="/tags/继承/" style="font-size: 15px;">继承</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/垃圾回收机制/" style="font-size: 15px;">垃圾回收机制</a> <a href="/tags/proxy/" style="font-size: 15px;">proxy</a> <a href="/tags/自定义行为/" style="font-size: 15px;">自定义行为</a> <a href="/tags/Symbol/" style="font-size: 15px;">Symbol</a> <a href="/tags/clock/" style="font-size: 15px;">clock</a> <a href="/tags/FileReader/" style="font-size: 15px;">FileReader</a> <a href="/tags/图片预览/" style="font-size: 15px;">图片预览</a> <a href="/tags/标签页间通信/" style="font-size: 15px;">标签页间通信</a> <a href="/tags/shadowDOM/" style="font-size: 15px;">shadowDOM</a> <a href="/tags/影子根/" style="font-size: 15px;">影子根</a> <a href="/tags/影子宿主/" style="font-size: 15px;">影子宿主</a> <a href="/tags/jsonp/" style="font-size: 15px;">jsonp</a> <a href="/tags/CORS/" style="font-size: 15px;">CORS</a> <a href="/tags/服务器代理/" style="font-size: 15px;">服务器代理</a> <a href="/tags/跨域/" style="font-size: 15px;">跨域</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/09/hexo-theme/">hexo-theme</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/09/hello-world/">hello-world</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/Vuex的Mutation学习/">Vuex 的 Mutation 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/Vuex的Action学习/">Vuex 的 Action 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/25/Vuex的Getter学习/">Vuex 的 Getter 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/24/Vuex的State学习/">Vuex 的 State 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/23/vue的混合mixins学习/">vue的混合mixins学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/28/vue+element的upload组件学习模板/">vue+element的upload组件学习模板</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/28/vue+element的tree组件学习模板/">vue+element的tree组件学习模板</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/vue+element的table组件学习模板/">vue+element的table组件学习模板</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">kaelyn.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>