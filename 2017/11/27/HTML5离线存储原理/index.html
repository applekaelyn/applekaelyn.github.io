<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>HTML5离线存储原理 | kaelyn</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">HTML5离线存储原理</h1><a id="logo" href="/.">kaelyn</a><p class="description">kaelyn's blog</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">HTML5离线存储原理</h1><div class="post-meta">Nov 27, 2017<span> | </span><span class="category"><a href="/categories/html5/">html5</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理和环境"><span class="toc-number">1.</span> <span class="toc-text">原理和环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解析清单"><span class="toc-number">2.</span> <span class="toc-text">解析清单</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CACHE-MANIFEST"><span class="toc-number">2.1.</span> <span class="toc-text">CACHE MANIFEST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NETWORK"><span class="toc-number">2.2.</span> <span class="toc-text">NETWORK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FALLBACK"><span class="toc-number">2.3.</span> <span class="toc-text">FALLBACK</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更新缓存"><span class="toc-number">3.</span> <span class="toc-text">更新缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Demo"><span class="toc-number">4.</span> <span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存立即执行"><span class="toc-number">5.</span> <span class="toc-text">缓存立即执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注意事项"><span class="toc-number">6.</span> <span class="toc-text">注意事项</span></a></li></ol></div></div><div class="post-content"><p>&emsp;&emsp;使用 HTML5，通过创建 <strong>cache manifest</strong> 文件，可轻松创建 web 应用的<strong>离线版本</strong>。<br>&emsp;&emsp;HTML5 引入了<strong>应用程序缓存</strong>，这意味着web应用可进行缓存，并可在<strong>没有网络</strong>时进行访问。<br>&emsp;&emsp;应用程序缓存为应用带来三个<strong>优势</strong>：</p>
<ol>
<li><strong>离线浏览</strong>：用户可在离线时使用它们。</li>
<li><strong>速度</strong>：已经缓存的资源加载得更快。</li>
<li><strong>减少服务器负载</strong>：浏览器将只从服务器下载更改过的资源。</li>
</ol>
<hr>
<h2 id="原理和环境"><a href="#原理和环境" class="headerlink" title="原理和环境"></a>原理和环境</h2><p>&emsp;&emsp;如上面提到的 HTML5 的离线存储是基于一个新建的<code>.appcache</code>文件的，通过这个文件上的<strong>解析清单离线存储资源</strong>，这些资源就会像 cookie 一样被<strong>存储</strong>了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。<br>&emsp;&emsp;就像cookie一样，html5 的离线存储也需要服务器环境。</p>
<hr>
<h2 id="解析清单"><a href="#解析清单" class="headerlink" title="解析清单"></a>解析清单</h2><p>&emsp;&emsp;在开始之前要先了解下<code>manifest</code>（即 <strong>.appcache 文件</strong>），上面的解析清单要怎么写。<br>&emsp;&emsp;<strong>manifest 文件</strong>是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。<br>manifest 文件可分为<strong>三个部分</strong>：</p>
<ul>
<li><strong>CACHE MANIFEST</strong> ：在此标题下列出的文件将在首次下载后进行缓存。</li>
<li><strong>NETWORK</strong> ：在此标题下列出的文件需要与服务器的连接，且不会被缓存。</li>
<li><strong>FALLBACK</strong>：在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）。</li>
</ul>
<p>&emsp;&emsp;<strong>在线</strong>的情况下,用户代理每次访问页面，都会去读一次 <strong>manifest</strong>，如果发现其<strong>改变</strong>, 则<strong>重新加载全部清单中的资源</strong>。</p>
<h3 id="CACHE-MANIFEST"><a href="#CACHE-MANIFEST" class="headerlink" title="CACHE MANIFEST"></a>CACHE MANIFEST</h3><p>&emsp;&emsp;第一行，<strong>CACHE MANIFEST</strong>，是<strong>必需</strong>的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST /theme.css /logo.gif /main.js</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面的 manifest 文件列出了三个资源：一个 CSS 文件，一个 GIF 图像，以及一个 JavaScript 文件。当 manifest 文件加载后，浏览器会从网站的根目录下载这三个文件。然后，无论用户何时与因特网断开连接，这些资源依然是<strong>可用</strong>的。<br><br></p>
<h3 id="NETWORK"><a href="#NETWORK" class="headerlink" title="NETWORK"></a>NETWORK</h3><p>&emsp;&emsp;下面的 <strong>NETWORK</strong> 小节规定文件 “login.asp” 永远<strong>不会被缓存</strong>，且<strong>离线时是不可用的</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NETWORK: login.asp</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以使用 <strong>“*”</strong> 来指示所有其他资源/文件都需要因特网连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NETWORK: *</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>白名单</strong>，使用通配符 <strong>“*”</strong>。 则会进入<strong>白名单的 open 状态</strong>。这种状态下，所有不在相关 Cache 区域出现的 url 都<strong>默认使用HTTP相关缓存头策略</strong>。</p>
</blockquote>
<p><br></p>
<h3 id="FALLBACK"><a href="#FALLBACK" class="headerlink" title="FALLBACK"></a>FALLBACK</h3><p>&emsp;&emsp;下面的 <strong>FALLBACK</strong> 小节规定如果无法建立因特网连接，则用 “offline.html” 替代 /html5/ 目录中的所有文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FALLBACK：/html5/ /404.html</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注释：<strong>第一个 URI 是资源，第二个是替补。</strong></p>
</blockquote>
<hr>
<h2 id="更新缓存"><a href="#更新缓存" class="headerlink" title="更新缓存"></a>更新缓存</h2><p>&emsp;&emsp;一旦应用被缓存，它就会保持缓存直到发生下列情况：</p>
<ul>
<li>用户清空浏览器缓存。</li>
<li>manifest 文件被修改。</li>
<li>由程序来更新应用缓存。</li>
</ul>
<hr>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|-- index.html </span><br><span class="line">|-- demo.appcache </span><br><span class="line">|-- image </span><br><span class="line">    |-- 01.jpg </span><br><span class="line">    |-- 02.jpg</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// index.html</span><br><span class="line">&lt;!DOCTYPE html&gt; </span><br><span class="line">&lt;html lang=&quot;en&quot; manifest=&quot;demo.appcache&quot;&gt; </span><br><span class="line">&lt;head&gt; </span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt; </span><br><span class="line">    &lt;title&gt;HTML5离线存储&lt;/title&gt;</span><br><span class="line">&lt;/head&gt; </span><br><span class="line">&lt;body&gt; </span><br><span class="line">    &lt;img src=&quot;image/01.jpg&quot; alt=&quot;&quot;&gt; </span><br><span class="line">    &lt;img src=&quot;image/02.jpg&quot; alt=&quot;&quot;&gt; </span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// demo.appcache</span><br><span class="line">CACHE MANIFEST #v01 image/01.jpg</span><br><span class="line">NETWORK: *</span><br><span class="line">FALLBACK: /</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;image 文件夹下存储着：<br>&emsp;&emsp;&emsp;&emsp;01.jpg<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<img src="http://img.blog.csdn.net/20171127192616148" alt="01.jpg"><br><br><br>&emsp;&emsp;&emsp;&emsp;02.jpg<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<img src="http://img.blog.csdn.net/20171127192709517" alt="02.jpg"><br><br><br>&emsp;&emsp;当服务器开启时：<br><img src="http://img.blog.csdn.net/20171127192818894" alt="服务器开启时"><br><br><br>&emsp;&emsp;当服务器关闭时（是关闭，暂停看不出效果）:<br><img src="http://img.blog.csdn.net/20171127192857782" alt="服务器关闭时"></p>
<p>&emsp;&emsp;可以看见图片1成功被离线展示出来了，图片2像正常情况一样显示不出来。<br>&emsp;&emsp;现在我想把图片2和图片1的位置换一下呢：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt; </span><br><span class="line">    &lt;img src=&quot;image/02.jpg&quot; alt=&quot;&quot;&gt; </span><br><span class="line">    &lt;img src=&quot;image/01.jpg&quot; alt=&quot;&quot;&gt; </span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这时候发现问题来了，html 明明修改了为什么图片没有置换过来呢，我不是在 <strong>demo.appcache 文件</strong>的 <strong>NETWORK</strong> 写了<strong>星号</strong>吗?除了 <strong>CACHE MANIFEST 文件</strong>其它都采用<strong>在线模式</strong>。查资料得知：<strong>引入 manifest 的页面,即使没有被列入缓存清单中，仍然会被用户代理缓存。</strong><br>&emsp;&emsp;好吧，那我把 <strong>.appcache 文件</strong>更新下，于是乎把头部的版本号修改一下 #v02。刷新下页面还是没反应！再刷新，有了！为什么？<br>&emsp;&emsp;对于浏览器来说，<strong>manifest 的加载是要晚于其他资源的</strong>。这就导致 <strong>check manifest</strong> 的过程是<strong>滞后</strong>的。发现 <strong>manifest</strong> 改变。所有浏览器的实现都是紧随着做<strong>静默更新资源</strong>。以保证下次pv，应用到更新。</p>
<p>&emsp;&emsp;通过控制台我们能够窥探一二：<br>&emsp;&emsp;<strong>第一次刷新</strong>，应用程序缓存更新准备事件：<br>&emsp;&emsp;&emsp;&emsp;<img src="http://img.blog.csdn.net/20171127193352813" alt="第一次刷新"><br>&emsp;&emsp;<strong>第二次刷新</strong>才会看到效果：<br>&emsp;&emsp;&emsp;&emsp;<img src="http://img.blog.csdn.net/20171127193432327" alt="第二次刷新"></p>
<hr>
<h2 id="缓存立即执行"><a href="#缓存立即执行" class="headerlink" title="缓存立即执行"></a>缓存立即执行</h2><p>&emsp;&emsp;我们的产品已经更新了用户却要第二次进来才能够看到，这样用户体验也太差了吧，有什么方式能够解决呢？好在 <strong>html5</strong> 给 <strong>javascript</strong> 提供了相关的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Using_the_application_cache" target="_blank" rel="noopener">API</a>。<br>&emsp;&emsp;API 篇幅太多自行查看吧，这里我晒下我测试成功的 code：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* code1,简单粗暴的 */</span><br><span class="line">applicationCache.onupdateready = function()&#123;</span><br><span class="line">    applicationCache.swapCache();</span><br><span class="line">    location.reload();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* code2，缓存公用方法 */</span><br><span class="line">var EventUtil = &#123;</span><br><span class="line">    addHandler: function(element, type, handler) &#123;</span><br><span class="line">        if (element.addEventListener) &#123;</span><br><span class="line">            element.addEventListener(type, handler, false);</span><br><span class="line">        &#125; else if (element.attachEvent) &#123;</span><br><span class="line">            element.attachEvent(“on” + type, handler);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            element[&quot;on&quot; + type] = handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">EventUtil.addHandler(applicationCache, “updateready”, function() &#123; </span><br><span class="line">    // 缓存更新并已下载，要在下次进入页面生效</span><br><span class="line">    // 检查缓存 manifest 文件是否更新 ps:页面加载默认检查一次。</span><br><span class="line">    applicationCache.update(); </span><br><span class="line">    // 交换到新的缓存项中，交换了要下次进入页面才生效</span><br><span class="line">    applicationCache.swapCache(); </span><br><span class="line">    </span><br><span class="line">    location.reload(); // 重新载入页面</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;code1 一般用<strong>在页面加载时直接触发</strong>，而 code2 的方式可<strong>后期检查更新</strong>。</p>
<hr>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>站点离线存储的<strong>容量限制是5M</strong>。</li>
<li>如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程将视为<strong>失败</strong>，浏览器继续全部使用老的缓存。</li>
<li>引用 manifest 的 html 必须与 manifest 文件<strong>同源</strong>，在同一个域下。</li>
<li>在 manifest 中使用的<strong>相对路径</strong>，相对参照物为 manifest 文件。</li>
<li>CACHE MANIFEST 字符串应在<strong>第一行</strong>，且<strong>必不可少</strong>。</li>
<li>系统会<strong>自动缓存引用清单文件的 HTML 文件</strong>。</li>
<li>manifest 文件中 CACHE 则与 NETWORK、FALLBACK 的位置顺序没有关系，如果是<strong>隐式声明</strong>需要在最前面。</li>
<li>FALLBACK 中的资源必须和 manifest 文件<strong>同源</strong>。</li>
<li>当一个资源被缓存后，该浏览器<strong>直接请求这个绝对路径也会访问缓存中的资源。</strong></li>
<li>站点中的其他页面<strong>即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。</strong></li>
<li><p>当 manifest 文件发生改变时，资源请求本身也会<strong>触发更新</strong>。</p>
<p><br></p>
<blockquote>
<p>原文出处：<a href="http://www.codeceo.com/article/html5-cache.html" target="_blank" rel="noopener">HTML5离线存储原理及实现</a></p>
</blockquote>
</li>
</ul>
</div><div class="tags"><a href="/tags/html5/">html5</a><a href="/tags/离线存储/">离线存储</a><a href="/tags/appcache/">appcache</a></div><div class="post-nav"><a class="pre" href="/2017/11/27/瀑布流布局/">瀑布流布局</a><a class="next" href="/2017/11/26/BFC与IFC /">BFC与IFC</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/">ES6</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/css3/">css3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/html5/">html5</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/node-js/">node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/questions/">questions</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue/">vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/函数参数表达/" style="font-size: 15px;">函数参数表达</a> <a href="/tags/BFC/" style="font-size: 15px;">BFC</a> <a href="/tags/css3/" style="font-size: 15px;">css3</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/绝对底部/" style="font-size: 15px;">绝对底部</a> <a href="/tags/StickyFoot/" style="font-size: 15px;">StickyFoot</a> <a href="/tags/图片压缩/" style="font-size: 15px;">图片压缩</a> <a href="/tags/canvas/" style="font-size: 15px;">canvas</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/vuex/" style="font-size: 15px;">vuex</a> <a href="/tags/action/" style="font-size: 15px;">action</a> <a href="/tags/getter/" style="font-size: 15px;">getter</a> <a href="/tags/mutation/" style="font-size: 15px;">mutation</a> <a href="/tags/state/" style="font-size: 15px;">state</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/let/" style="font-size: 15px;">let</a> <a href="/tags/const/" style="font-size: 15px;">const</a> <a href="/tags/块级作用域/" style="font-size: 15px;">块级作用域</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/node-js/" style="font-size: 15px;">node.js</a> <a href="/tags/express/" style="font-size: 15px;">express</a> <a href="/tags/promise/" style="font-size: 15px;">promise</a> <a href="/tags/element/" style="font-size: 15px;">element</a> <a href="/tags/table/" style="font-size: 15px;">table</a> <a href="/tags/tree/" style="font-size: 15px;">tree</a> <a href="/tags/upload/" style="font-size: 15px;">upload</a> <a href="/tags/mixins/" style="font-size: 15px;">mixins</a> <a href="/tags/模块化/" style="font-size: 15px;">模块化</a> <a href="/tags/定义模块/" style="font-size: 15px;">定义模块</a> <a href="/tags/引入模块/" style="font-size: 15px;">引入模块</a> <a href="/tags/暴露模块/" style="font-size: 15px;">暴露模块</a> <a href="/tags/三栏布局/" style="font-size: 15px;">三栏布局</a> <a href="/tags/圣杯布局/" style="font-size: 15px;">圣杯布局</a> <a href="/tags/双飞翼/" style="font-size: 15px;">双飞翼</a> <a href="/tags/形状/" style="font-size: 15px;">形状</a> <a href="/tags/正方形容器/" style="font-size: 15px;">正方形容器</a> <a href="/tags/图片上传/" style="font-size: 15px;">图片上传</a> <a href="/tags/padding/" style="font-size: 15px;">padding</a> <a href="/tags/Sass/" style="font-size: 15px;">Sass</a> <a href="/tags/浏览器引擎前缀/" style="font-size: 15px;">浏览器引擎前缀</a> <a href="/tags/IFC/" style="font-size: 15px;">IFC</a> <a href="/tags/函数参数传参/" style="font-size: 15px;">函数参数传参</a> <a href="/tags/scroll/" style="font-size: 15px;">scroll</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/Set/" style="font-size: 15px;">Set</a> <a href="/tags/WeakSet/" style="font-size: 15px;">WeakSet</a> <a href="/tags/Map/" style="font-size: 15px;">Map</a> <a href="/tags/WeakMap/" style="font-size: 15px;">WeakMap</a> <a href="/tags/对象字面量/" style="font-size: 15px;">对象字面量</a> <a href="/tags/无缝滚动/" style="font-size: 15px;">无缝滚动</a> <a href="/tags/模板字符串/" style="font-size: 15px;">模板字符串</a> <a href="/tags/Template-String/" style="font-size: 15px;">Template String</a> <a href="/tags/瀑布流布局/" style="font-size: 15px;">瀑布流布局</a> <a href="/tags/Generator/" style="font-size: 15px;">Generator</a> <a href="/tags/箭头函数/" style="font-size: 15px;">箭头函数</a> <a href="/tags/Arrow-Function/" style="font-size: 15px;">Arrow Function</a> <a href="/tags/class/" style="font-size: 15px;">class</a> <a href="/tags/表达式解构/" style="font-size: 15px;">表达式解构</a> <a href="/tags/multer/" style="font-size: 15px;">multer</a> <a href="/tags/文件上传/" style="font-size: 15px;">文件上传</a> <a href="/tags/html5/" style="font-size: 15px;">html5</a> <a href="/tags/离线存储/" style="font-size: 15px;">离线存储</a> <a href="/tags/appcache/" style="font-size: 15px;">appcache</a> <a href="/tags/继承/" style="font-size: 15px;">继承</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/垃圾回收机制/" style="font-size: 15px;">垃圾回收机制</a> <a href="/tags/proxy/" style="font-size: 15px;">proxy</a> <a href="/tags/自定义行为/" style="font-size: 15px;">自定义行为</a> <a href="/tags/Symbol/" style="font-size: 15px;">Symbol</a> <a href="/tags/clock/" style="font-size: 15px;">clock</a> <a href="/tags/FileReader/" style="font-size: 15px;">FileReader</a> <a href="/tags/图片预览/" style="font-size: 15px;">图片预览</a> <a href="/tags/标签页间通信/" style="font-size: 15px;">标签页间通信</a> <a href="/tags/shadowDOM/" style="font-size: 15px;">shadowDOM</a> <a href="/tags/影子根/" style="font-size: 15px;">影子根</a> <a href="/tags/影子宿主/" style="font-size: 15px;">影子宿主</a> <a href="/tags/jsonp/" style="font-size: 15px;">jsonp</a> <a href="/tags/CORS/" style="font-size: 15px;">CORS</a> <a href="/tags/服务器代理/" style="font-size: 15px;">服务器代理</a> <a href="/tags/跨域/" style="font-size: 15px;">跨域</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/09/hexo-theme/">hexo-theme</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/09/hello-world/">hello-world</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/Vuex的Mutation学习/">Vuex 的 Mutation 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/Vuex的Action学习/">Vuex 的 Action 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/25/Vuex的Getter学习/">Vuex 的 Getter 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/24/Vuex的State学习/">Vuex 的 State 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/23/vue的混合mixins学习/">vue的混合mixins学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/28/vue+element的upload组件学习模板/">vue+element的upload组件学习模板</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/28/vue+element的tree组件学习模板/">vue+element的tree组件学习模板</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/vue+element的table组件学习模板/">vue+element的table组件学习模板</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">kaelyn.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>